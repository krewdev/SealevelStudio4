/**
 * Known Exploits and Vulnerabilities Database
 * Comprehensive knowledge base of security issues for AI analysis
 */

export interface Exploit {
  id: string;
  name: string;
  category: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  description: string;
  affected: string[];
  detection: string[];
  example?: string;
  mitigation: string[];
  references?: string[];
}

export const KNOWN_EXPLOITS: Exploit[] = [
  // Solana-Specific Vulnerabilities
  {
    id: 'sol-001',
    name: 'Missing Signer Check',
    category: 'Access Control',
    severity: 'Critical',
    description: 'Account is used without verifying it is a signer, allowing unauthorized access',
    affected: ['Solana Programs', 'Anchor Programs'],
    detection: [
      'Account used in instruction without #[account(signer)] constraint',
      'Manual signer check missing: account.key != authority',
      'CPI without signer verification'
    ],
    example: `#[derive(Accounts)]
pub struct Transfer<'info> {
    pub from: Account<'info, TokenAccount>, // MISSING: #[account(signer)]
    pub to: Account<'info, TokenAccount>,
}`,
    mitigation: [
      'Add #[account(signer)] constraint',
      'Verify account.key == expected_authority',
      'Use Anchor constraints: #[account(has_one = authority @ ErrorCode::Unauthorized)]'
    ],
    references: ['https://docs.solana.com/developing/programming-model/accounts#signers']
  },
  {
    id: 'sol-002',
    name: 'Account Ownership Bypass',
    category: 'Access Control',
    severity: 'Critical',
    description: 'Account ownership not verified, allowing substitution attacks',
    affected: ['Solana Programs'],
    detection: [
      'Account used without owner check',
      'Missing account.owner == expected_program_id',
      'PDA derivation not verified'
    ],
    example: `pub fn transfer(ctx: Context<Transfer>) -> Result<()> {
    // VULNERABLE: No ownership check
    let account = &ctx.accounts.user_account;
    account.balance += amount;
    Ok(())
}`,
    mitigation: [
      'Verify account.owner == TOKEN_PROGRAM_ID',
      'Use Anchor: #[account(owner = TokenProgram @ ErrorCode::InvalidOwner)]',
      'Validate PDA derivation matches expected seeds'
    ]
  },
  {
    id: 'sol-003',
    name: 'PDA Derivation Manipulation',
    category: 'Cryptography',
    severity: 'High',
    description: 'PDA derivation not validated, allowing malicious account substitution',
    affected: ['Solana Programs', 'Anchor Programs'],
    detection: [
      'PDA used without derivation verification',
      'Missing Pubkey::find_program_address check',
      'Seeds not validated'
    ],
    example: `pub fn initialize(ctx: Context<Initialize>, seeds: Vec<u8>) -> Result<()> {
    // VULNERABLE: PDA not verified
    let pda = ctx.accounts.pda.key();
    // Should verify: Pubkey::find_program_address(&[b"vault", seeds], program_id)
}`,
    mitigation: [
      'Always verify PDA derivation',
      'Use Anchor: #[account(seeds = [b"vault", user.key().as_ref()], bump)]',
      'Never trust user-provided PDA addresses'
    ]
  },
  {
    id: 'sol-004',
    name: 'Integer Overflow/Underflow',
    category: 'Arithmetic',
    severity: 'High',
    description: 'Unchecked arithmetic operations can overflow or underflow',
    affected: ['Rust Programs', 'Anchor Programs'],
    detection: [
      'Direct arithmetic: a + b, a - b without checks',
      'Missing checked_add, checked_sub',
      'No overflow protection'
    ],
    example: `pub fn transfer(amount: u64) -> Result<()> {
    // VULNERABLE: Can overflow
    balance = balance + amount;
    // Should use: balance.checked_add(amount).ok_or(ErrorCode::Overflow)?
}`,
    mitigation: [
      'Use checked_add, checked_sub, checked_mul',
      'Enable overflow checks in Rust',
      'Validate ranges before arithmetic'
    ]
  },
  {
    id: 'sol-005',
    name: 'Reentrancy Attack',
    category: 'Concurrency',
    severity: 'Critical',
    description: 'CPI or external call allows reentrancy before state update',
    affected: ['Solana Programs', 'Anchor Programs'],
    detection: [
      'State updated after external call',
      'CPI before balance update',
      'Missing reentrancy guards'
    ],
    example: `pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {
    // VULNERABLE: CPI before state update
    invoke(&transfer_instruction, &accounts)?;
    self.balance -= amount; // Too late!
}`,
    mitigation: [
      'Update state before external calls',
      'Use checks-effects-interactions pattern',
      'Implement reentrancy locks'
    ]
  },
  {
    id: 'sol-006',
    name: 'Account Data Deserialization',
    category: 'Input Validation',
    severity: 'High',
    description: 'Unsafe deserialization of account data can cause panics or data corruption',
    affected: ['Solana Programs'],
    detection: [
      'Unsafe try_from_slice without error handling',
      'Missing account data length checks',
      'Deserialization without validation'
    ],
    example: `pub fn process(ctx: Context<Process>) -> Result<()> {
    // VULNERABLE: Can panic
    let data = AccountData::try_from_slice(&ctx.accounts.account.data.borrow())?;
}`,
    mitigation: [
      'Validate account data length first',
      'Use safe deserialization with proper error handling',
      'Check account discriminator'
    ]
  },
  {
    id: 'sol-007',
    name: 'Missing Account Validation',
    category: 'Input Validation',
    severity: 'High',
    description: 'Account constraints not properly validated',
    affected: ['Anchor Programs'],
    detection: [
      'Missing #[account(has_one)] constraints',
      'No account relationship validation',
      'Missing mutability checks'
    ],
    example: `#[derive(Accounts)]
pub struct Update<'info> {
    pub user: Account<'info, User>,
    pub vault: Account<'info, Vault>, // MISSING: has_one = user
}`,
    mitigation: [
      'Add proper Anchor constraints',
      'Validate account relationships',
      'Use has_one, init_if_needed properly'
    ]
  },
  {
    id: 'sol-008',
    name: 'Token Account Validation Bypass',
    category: 'Token Security',
    severity: 'Critical',
    description: 'Token account not properly validated, allowing fake token accounts',
    affected: ['Token Programs', 'DeFi Protocols'],
    detection: [
      'Token account owner not checked',
      'Missing mint validation',
      'No token account state verification'
    ],
    example: `pub fn swap(ctx: Context<Swap>) -> Result<()> {
    // VULNERABLE: No token account validation
    let token_account = &ctx.accounts.token_account;
    // Should verify: token_account.owner == TOKEN_PROGRAM_ID
}`,
    mitigation: [
      'Verify token account owner',
      'Validate mint address',
      'Check token account state (frozen, closed)'
    ]
  },
  {
    id: 'sol-009',
    name: 'Price Oracle Manipulation',
    category: 'Oracle Security',
    severity: 'High',
    description: 'Price data not validated, allowing manipulation attacks',
    affected: ['DeFi Protocols', 'Lending Protocols'],
    detection: [
      'Single oracle source',
      'No price staleness check',
      'Missing price bounds validation'
    ],
    mitigation: [
      'Use multiple oracle sources',
      'Check price staleness (max age)',
      'Validate price bounds (min/max)',
      'Implement circuit breakers'
    ]
  },
  {
    id: 'sol-010',
    name: 'Flash Loan Arbitrage',
    category: 'DeFi Exploit',
    severity: 'Medium',
    description: 'Protocol vulnerable to flash loan price manipulation',
    affected: ['DEXs', 'Lending Protocols'],
    detection: [
      'Price calculated from single transaction',
      'No flash loan protection',
      'Atomic operations without checks'
    ],
    mitigation: [
      'Implement flash loan detection',
      'Use time-weighted average prices',
      'Add minimum liquidity requirements'
    ]
  },
  // General Web Vulnerabilities
  {
    id: 'web-001',
    name: 'SQL Injection',
    category: 'Injection',
    severity: 'Critical',
    description: 'User input directly concatenated into SQL queries',
    affected: ['Web Applications', 'Backend Services'],
    detection: [
      'String concatenation in SQL: "SELECT * FROM users WHERE id = " + userInput',
      'No parameterized queries',
      'Raw SQL with user input'
    ],
    example: `$sql = "SELECT * FROM users WHERE id = " . $_GET['id'];
$result = mysqli_query($conn, $sql);`,
    mitigation: [
      'Use parameterized queries',
      'Prepared statements',
      'Input validation and sanitization'
    ]
  },
  {
    id: 'web-002',
    name: 'Cross-Site Scripting (XSS)',
    category: 'Injection',
    severity: 'High',
    description: 'User input rendered without sanitization',
    affected: ['Web Applications'],
    detection: [
      'User input directly in HTML output',
      'No output encoding',
      'innerHTML with user data'
    ],
    example: `echo "Welcome, " . $_GET['name']; // VULNERABLE`,
    mitigation: [
      'Output encoding (HTML entities)',
      'Content Security Policy',
      'Input validation'
    ]
  },
  {
    id: 'web-003',
    name: 'Command Injection',
    category: 'Injection',
    severity: 'Critical',
    description: 'User input executed as system commands',
    affected: ['Backend Services', 'CLI Tools'],
    detection: [
      'system(), exec(), eval() with user input',
      'Shell command construction from user data',
      'No input sanitization'
    ],
    example: `system("ls " . $_GET['dir']); // VULNERABLE`,
    mitigation: [
      'Avoid command execution',
      'Use parameterized APIs',
      'Whitelist allowed commands',
      'Input validation'
    ]
  },
  {
    id: 'web-004',
    name: 'Path Traversal',
    category: 'File System',
    severity: 'High',
    description: 'User input allows accessing files outside intended directory',
    affected: ['File Servers', 'Backend Services'],
    detection: [
      'File paths from user input',
      'No path validation',
      '../ in file operations'
    ],
    example: `readfile($_GET['file']); // VULNERABLE: ../../../etc/passwd`,
    mitigation: [
      'Validate and sanitize paths',
      'Use basename()',
      'Whitelist allowed directories',
      'Canonicalize paths'
    ]
  },
  {
    id: 'web-005',
    name: 'Insecure Deserialization',
    category: 'Serialization',
    severity: 'Critical',
    description: 'Deserializing untrusted data can lead to RCE',
    affected: ['Backend Services', 'APIs'],
    detection: [
      'unserialize() with user input',
      'JSON.parse() with untrusted data',
      'Pickle, YAML deserialization'
    ],
    mitigation: [
      'Avoid deserializing untrusted data',
      'Use safe serialization formats',
      'Validate deserialized data',
      'Sandbox deserialization'
    ]
  },
  {
    id: 'web-006',
    name: 'Broken Authentication',
    category: 'Authentication',
    severity: 'Critical',
    description: 'Weak authentication mechanisms',
    affected: ['Web Applications'],
    detection: [
      'Weak password requirements',
      'No rate limiting on login',
      'Session fixation',
      'Missing 2FA'
    ],
    mitigation: [
      'Strong password policies',
      'Rate limiting',
      'Secure session management',
      'Multi-factor authentication'
    ]
  },
  {
    id: 'web-007',
    name: 'Sensitive Data Exposure',
    category: 'Data Protection',
    severity: 'High',
    description: 'Sensitive data exposed in logs, errors, or responses',
    affected: ['All Applications'],
    detection: [
      'API keys in logs',
      'Passwords in error messages',
      'Credit cards in responses',
      'Debug mode in production'
    ],
    mitigation: [
      'Encrypt sensitive data',
      'Don\'t log sensitive information',
      'Use environment variables',
      'Disable debug mode in production'
    ]
  },
  {
    id: 'web-008',
    name: 'XML External Entity (XXE)',
    category: 'Injection',
    severity: 'High',
    description: 'XML parser processes external entities',
    affected: ['XML Parsers', 'APIs'],
    detection: [
      'XML parsing with external entities enabled',
      'User-controlled XML input',
      'No entity restrictions'
    ],
    mitigation: [
      'Disable external entities',
      'Use simple data formats (JSON)',
      'Validate XML schemas',
      'Whitelist allowed entities'
    ]
  },
  {
    id: 'web-009',
    name: 'Broken Access Control',
    category: 'Authorization',
    severity: 'Critical',
    description: 'Missing or weak authorization checks',
    affected: ['Web Applications'],
    detection: [
      'No authorization checks',
      'Client-side only authorization',
      'Insecure direct object references'
    ],
    mitigation: [
      'Server-side authorization',
      'Role-based access control',
      'Verify permissions on every request'
    ]
  },
  {
    id: 'web-010',
    name: 'Security Misconfiguration',
    category: 'Configuration',
    severity: 'High',
    description: 'Insecure default configurations',
    affected: ['All Applications'],
    detection: [
      'Default credentials',
      'Unnecessary features enabled',
      'Missing security headers',
      'Verbose error messages'
    ],
    mitigation: [
      'Secure defaults',
      'Disable unused features',
      'Security headers (CSP, HSTS)',
      'Minimal error information'
    ]
  }
];

/**
 * Get exploits by category
 */
export function getExploitsByCategory(category: string): Exploit[] {
  return KNOWN_EXPLOITS.filter(e => e.category === category);
}

/**
 * Get exploits by severity
 */
export function getExploitsBySeverity(severity: Exploit['severity']): Exploit[] {
  return KNOWN_EXPLOITS.filter(e => e.severity === severity);
}

/**
 * Search exploits by keyword
 */
export function searchExploits(keyword: string): Exploit[] {
  const lower = keyword.toLowerCase();
  return KNOWN_EXPLOITS.filter(e => 
    e.name.toLowerCase().includes(lower) ||
    e.description.toLowerCase().includes(lower) ||
    e.category.toLowerCase().includes(lower) ||
    e.detection.some(d => d.toLowerCase().includes(lower))
  );
}

/**
 * Get exploit knowledge base as formatted string for AI prompts
 */
export function getExploitKnowledgeBase(): string {
  let kb = '=== KNOWN EXPLOITS AND VULNERABILITIES DATABASE ===\n\n';
  
  KNOWN_EXPLOITS.forEach(exploit => {
    kb += `[${exploit.id}] ${exploit.name} (${exploit.severity})\n`;
    kb += `Category: ${exploit.category}\n`;
    kb += `Description: ${exploit.description}\n`;
    kb += `Affected: ${exploit.affected.join(', ')}\n`;
    kb += `Detection Patterns:\n`;
    exploit.detection.forEach(pattern => {
      kb += `  - ${pattern}\n`;
    });
    if (exploit.example) {
      kb += `Example:\n${exploit.example}\n`;
    }
    kb += `Mitigation:\n`;
    exploit.mitigation.forEach(mit => {
      kb += `  - ${mit}\n`;
    });
    kb += '\n';
  });
  
  return kb;
}

